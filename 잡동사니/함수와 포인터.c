#include<stdio.h>
void array_print(int* p) {          //매개변수 표현을 int p[]로 해도 됨. int p[]도 포인터라는 의미.
	int i = 0;
	for (i = 0; i < 12; i++) {
		printf("a[%d] = 값 : %d %d 주소 : %d \n", i, p[i], *(p + i), &p[i]);
	}
}
int main(void) {
	int k = 1000, i = 0;
	int a[6] = { 10,20,30,40,50 };
	int *p = a;
	for (i = 0; i < 12; i++) {
		printf("a[%d] = 값 : %d %d 주소 : %d \n", i, a[i], *(a + i), &a[i]);
	}
	printf("k=%d 주소 =%d, %d\n", k, &k, &a[11]);           //마지막 배열과 24BYTE차이.
	array_print(a);										   //여기에서 매개변수로 *a가 들어간 것.
	return 0;
}                                                          //결국 a[n]으로 선언을 하면 a[n+5]만큼 공간을 확보하고
														   //그 다음 메모리(a[n+6]에 다음 변수를 저장하기 때문에 24BYTE의 주소차가 나타나는 것.
//그냥 메모리 여유가 있어서 그렇댄다. 포인터배열이 계속 되면 나란히 정돈된 메모리를 침범하여 그 값까지 바꿔버릴 수도 있기 때문에
//(여기에서 a[11]이 k가 되듯이) 여유분을 둔 것이다. 그래서 새로운 선언을 하면 24BYTE씩 여유를 두고 가는 것 같다.