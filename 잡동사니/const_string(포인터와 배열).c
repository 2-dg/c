#include<stdio.h>
int main(void)
{
	char a = 0;									 //str *str = 'abc';가 아님
	//char* str = "abc";						 //이게 맞음 - 1BYTE 캐릭터 포인터 타입 str = 4BYTE (포인터, 지역변수)
	//printf("문자열 번지 = %x \n",str);          //보통 번지는 16진수로 찍는다
	//printf("문자열 첫번째 값 = %c", str[0]);	 //str[0]이 첫번째 str에 할당된 첫번째 주소이기 때문에 a가 출력
	//str[0] = 'k';								 //하면 오류가 생김.
												 //이 방식은 수정이 안되기 때문에 상수로만 활용하겠다는 의미다.
												 //결국 밑과의 차이는 포인터로 선언하면 장소 하나만 수정이 안 된다는 건데
												 //그건 왜인지는 모르겠다. 한번 물어보자.


	char str[4] = "abc";						 //문자열
	printf("str에 입력된 문자열 %s \n", str);
	printf("문자열 첫번째 값 = %c \n", str[0]);
	str[0] = 'k';
	printf("변경된 문자열 첫번째 값 = %c \n", str[0]);   //이 방식은 수정이 되기 때문에 반드시 수정하겠다는 의미이다.
												 //아마도 이건 str[0]의 주소와 char로 선언한 a의 주소가 똑같이 나올 것이다.	
	printf("문자열 첫번째 값의 주소 = %x \n", &str[0]);	 //k가 들어있다 (16행 참조)
	printf("문자열 첫번째 값 = 10진수 : %d 문자 :  %c \n", str[0], str[0]);
	printf("문자열 두번째 값의 주소 = %x \n", &str[1]);	 //가 들어있다
	printf("문자열 두번째 값 = 10진수 : %d 문자 :  %c \n", str[1], str[1]);
	printf("문자열 세번째 값의 주소 = %x \n", &str[2]);	 //
	printf("문자열 세번째 값 = 10진수 : %d 문자 :  %c \n", str[2], str[2]);
	printf("문자열 네번째 값의 주소 = %x \n", &str[3]);   //null값. 출력하면 문자열 16진수로 차례대로 출력됨.
	printf("문자열 네번째 값 = 10진수 : %d 문자 :  %c \n", str[3], str[3]);
	printf("문자열 다섯번째 값의 주소 = %x \n", &str[4]); //값 할당은 안돼있어도 주소는 있기 때문에 출력은 된다
	printf("문자열 다섯번째 값 =10진수 : %d 문자 :  %c \n", str[4], str[4]);
	                                                     //이건 할당이 안돼있으므로 ?가 뜬다 (주소는 있지만)
	a = getchar();										 //계속하려면 아무 키나 입력하세요 안 뜨게
	return 0;											 //운영체제는 리턴 뒤에오는 숫자는 무시함
}